import{_ as t,E as e,c as h,m as s,a as i,J as n,w as l,V as p,o as k}from"./chunks/framework.szLWUyCm.js";const R=JSON.parse('{"title":"三、CSRF攻击","description":"","frontmatter":{},"headers":[],"relativePath":"rear/flask/CSRF攻击.md","filePath":"rear/flask/CSRF攻击.md","lastUpdated":null}'),r={name:"rear/flask/CSRF攻击.md"},d=s("h1",{id:"三、csrf攻击",tabindex:"-1"},[i("三、CSRF攻击 "),s("a",{class:"header-anchor",href:"#三、csrf攻击","aria-label":'Permalink to "三、CSRF攻击"'},"​")],-1),E=s("p",null,"CSRF（Cross-Site Request Forgery，跨站请求伪造）是一种利用用户在已登录的情况下，被攻击网站的认证信息（如 Cookie、Session）来发起恶意请求的攻击方式。攻击者利用受害者的身份，向受害者已经认证过的网站发送伪造的请求，以执行某些恶意操作。",-1),c=s("p",null,"攻击原理如下：",-1),o=s("strong",null,"用户已认证登录",-1),g=s("li",null,[s("strong",null,"攻击者构造恶意页面"),i("：攻击者创建一个恶意网页（通常是一个精心设计的网页表单），将这个网页地址发送给受害者，或者通过其他方式诱导受害者访问。")],-1),y=s("li",null,[s("strong",null,"受害者访问恶意页面"),i("：受害者在已经登录过网站 A 的情况下，访问了攻击者提供的恶意页面。")],-1),F=s("li",null,[s("strong",null,"恶意请求被发送"),i("：恶意页面中包含了对网站 A 的请求，利用了受害者在网站 A 的认证信息（如 Cookie），浏览器会在后台自动发送这个请求到网站 A。")],-1),u=s("li",null,[s("strong",null,"网站 A 执行恶意请求"),i("：由于请求中包含了受害者的认证信息，网站 A 会将这个请求当作是受害者的合法请求来处理，并执行其中的操作，比如修改用户信息、发表言论、转账等。")],-1),b=p("",10),m=p("",9),C=p("",16);function A(D,_,f,v,B,q){const a=e("font");return k(),h("div",null,[d,E,c,s("ol",null,[s("li",null,[o,i("：受害者在浏览器中访问了一个已认证过的网站 A，并登录成功，生成了相应的认证信息，如 Cookie 或 Session。（"),n(a,{color:"red"},{default:l(()=>[i("保存在浏览器")]),_:1}),i("）")]),g,y,F,u]),b,s("blockquote",null,[n(a,{color:"red"},{default:l(()=>[i("使用CSRFProject创建对象后，其会自动在Jinja2模板的上下文中添加`csrf_token`函数，调用此函数，自动生产`csrf_token`字符串")]),_:1})]),m,n(a,{color:"red"},{default:l(()=>[i("首先从模板文件中获取 csrf token 的值，然后通过设置 beforeSend 方法，使得在每次发送请求之前都把csrf token 设置到请求头中，这样即可完成 csrf 的验证")]),_:1}),C])}const T=t(r,[["render",A]]);export{R as __pageData,T as default};
